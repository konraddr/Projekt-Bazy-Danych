
DROP VIEW IF EXISTS raport_przychodow CASCADE;
DROP TRIGGER IF EXISTS trg_walidacja_dat ON rezerwacje;
DROP TRIGGER IF EXISTS trg_auto_oplacenie ON platnosci;
DROP TRIGGER IF EXISTS trg_archiwizacja_usera ON uzytkownik;
DROP TRIGGER IF EXISTS trg_loguj_zmiany ON rezerwacje;
DROP TRIGGER IF EXISTS trg_blokada_bezpieczenstwa ON rezerwacje;
DROP TRIGGER IF EXISTS trg_loguj_zmiany_json ON rezerwacje;

DROP FUNCTION IF EXISTS waliduj_daty_rezerwacji CASCADE;
DROP FUNCTION IF EXISTS auto_status_rezerwacji CASCADE;
DROP FUNCTION IF EXISTS archiwizuj_przed_usunieciem CASCADE;
DROP FUNCTION IF EXISTS loguj_zmiane_statusu CASCADE;
DROP FUNCTION IF EXISTS sprawdz_blokade_klienta CASCADE;
DROP FUNCTION IF EXISTS loguj_zmiane_statusu_json CASCADE;
DROP FUNCTION IF EXISTS dokonaj_rezerwacji CASCADE;
DROP FUNCTION IF EXISTS anuluj_rezerwacje_klienta CASCADE;

DROP TABLE IF EXISTS archiwum_uzytkownikow CASCADE;
DROP TABLE IF EXISTS logi_systemowe CASCADE;
DROP TABLE IF EXISTS logi_nosql CASCADE;
DROP TABLE IF EXISTS platnosci CASCADE;
DROP TABLE IF EXISTS rezerwacje CASCADE;
DROP TABLE IF EXISTS pokoje CASCADE;
DROP TABLE IF EXISTS uzytkownik CASCADE;
DROP TABLE IF EXISTS hotele CASCADE;
DROP TABLE IF EXISTS konfiguracja CASCADE;
DROP TABLE IF EXISTS progi_zajetosci CASCADE;



-- Tabela A: Parametryzacja Systemu (Zmienne globalne)
CREATE TABLE konfiguracja (
    klucz VARCHAR(50) PRIMARY KEY,
    wartosc NUMERIC(10, 4),
    opis TEXT
);

-- Tabela B: Yield Management (Dynamiczne Ceny wg Zajętości)
CREATE TABLE progi_zajetosci (
    id SERIAL PRIMARY KEY,
    procent_od INT,
    procent_do INT,
    mnoznik NUMERIC(4, 2),
    opis VARCHAR(100)
);

-- Tabela C: Hotele (z sezonowością)
CREATE TABLE hotele (
    hotel_id SERIAL PRIMARY KEY,
    nazwa VARCHAR(100),
    miasto VARCHAR(100),
    mnoznik_lato NUMERIC(4, 2) DEFAULT 1.00,
    mnoznik_zima NUMERIC(4, 2) DEFAULT 1.00
);

-- Tabela D: Użytkownicy (z rolami i blokadą)
CREATE TABLE uzytkownik (
    id_uzytkownika SERIAL PRIMARY KEY,
    imie VARCHAR(50),
    nazwisko VARCHAR(50),
    email VARCHAR(100) UNIQUE NOT NULL,
    haslo VARCHAR(100) DEFAULT '1234',
    nr_tel VARCHAR(20),
    rola VARCHAR(20) DEFAULT 'klient', -- 'admin', 'manager', 'klient'
    czy_zablokowany BOOLEAN DEFAULT FALSE,
    manager_hotel_id INTEGER REFERENCES hotele(hotel_id) -- Tylko dla Managera
);

-- Tabela E: Pokoje
CREATE TABLE pokoje (
    id_pokoj SERIAL PRIMARY KEY,
    hotel_id INTEGER REFERENCES hotele(hotel_id),
    nr_pokoj VARCHAR(10),
    typ_pokoju VARCHAR(50),
    pojemnosc INTEGER,
    max_dzieci INTEGER DEFAULT 0,
    cena_doba NUMERIC(10, 2)
);

-- Tabela F: Rezerwacje
CREATE TABLE rezerwacje (
    id_rezerwacji SERIAL PRIMARY KEY,
    id_uzytkownika INTEGER REFERENCES uzytkownik(id_uzytkownika) ON DELETE CASCADE,
    id_pokoj INTEGER REFERENCES pokoje(id_pokoj),
    rezerwacja_od DATE,
    rezerwacja_do DATE,
    liczba_dzieci INTEGER,
    cena_ostateczna NUMERIC(10, 2),
    status VARCHAR(20) DEFAULT 'potwierdzona',
    data_utworzenia TIMESTAMP DEFAULT NOW()
);

-- Tabela G: Płatności
CREATE TABLE platnosci (
    id_platnosci SERIAL PRIMARY KEY,
    id_rezerwacji INTEGER REFERENCES rezerwacje(id_rezerwacji) ON DELETE CASCADE,
    kwota NUMERIC(10, 2),
    status VARCHAR(20) DEFAULT 'oczekujaca',
    rabat NUMERIC(10, 2) DEFAULT 0
);

-- Tabela H: Logi Relacyjne (SQL)
CREATE TABLE logi_systemowe (
    id_logu SERIAL PRIMARY KEY,
    id_rezerwacji INTEGER,
    stary_status VARCHAR(20),
    nowy_status VARCHAR(20),
    data_zmiany TIMESTAMP DEFAULT NOW(),
    komunikat TEXT
);

-- Tabela I: Logi Nierelacyjne (NoSQL / JSONB)
CREATE TABLE logi_nosql (
    id SERIAL PRIMARY KEY,
    data_zdarzenia TIMESTAMP DEFAULT NOW(),
    dokument_json JSONB
);

-- Tabela J: Archiwum Użytkowników
CREATE TABLE archiwum_uzytkownikow (
    id_archiwum SERIAL PRIMARY KEY,
    id_starego_uzytkownika INT,
    email VARCHAR(100),
    data_usuniecia TIMESTAMP DEFAULT NOW(),
    powod TEXT
);


INSERT INTO konfiguracja (klucz, wartosc, opis) VALUES 
('sezon_lato_mnoznik', 1.20, 'Opcja zapasowa globalna'), -- Używane jeśli hotel nie ma własnego
('sezon_zima_mnoznik', 0.90, 'Opcja zapasowa globalna'),
('lojalnosc_prog', 10, 'Liczba rezerwacji do rabatu'),
('lojalnosc_rabat', 0.015, 'Rabat stałego klienta (1.5%)'),
('anulowanie_limit_dni', 3, 'Dni do bezpłatnego anulowania'),
('anulowanie_kara_proc', 0.50, 'Kara za późne anulowanie');

INSERT INTO progi_zajetosci (procent_od, procent_do, mnoznik, opis) VALUES 
(0, 30, 0.90, 'Niskie obłożenie (Promocja -10%)'),
(31, 70, 1.00, 'Standard'),
(71, 90, 1.20, 'Wysokie obłożenie (+20%)'),
(91, 100, 1.50, 'Ostatnie pokoje (+50%)');


-- FUNKCJA GŁÓWNA: Rezerwacja z Dynamic Pricing i Yield Management
CREATE OR REPLACE FUNCTION dokonaj_rezerwacji(
    p_uid INT, p_pid INT, p_od DATE, p_do DATE, p_dzieci INT
) RETURNS TEXT AS $$
DECLARE
    v_cena NUMERIC; v_total NUMERIC; v_konflikt INT; v_new_id INT; v_max_dzieci INT;
    v_historia INT; v_rabat NUMERIC := 0; v_msg_info TEXT := ''; 
    v_miesiac INT; v_is_blocked BOOLEAN;
    
    -- Zmienne konfiguracyjne
    cfg_prog INT; cfg_rabat_proc NUMERIC;
    
    -- Zmienne Hotelowe i Dynamiczne
    v_hotel_id INT; v_hotel_lato NUMERIC; v_hotel_zima NUMERIC; v_hotel_nazwa VARCHAR;
    v_total_pokoje INT; v_zajete_pokoje INT; v_procent_zajetosci INT; 
    v_mnoznik_dyn NUMERIC; v_opis_dyn VARCHAR;
BEGIN
    -- 1. POBRANIE PARAMETRÓW
    SELECT wartosc INTO cfg_prog FROM konfiguracja WHERE klucz='lojalnosc_prog';
    SELECT wartosc INTO cfg_rabat_proc FROM konfiguracja WHERE klucz='lojalnosc_rabat';

    -- 2. WALIDACJE
    SELECT czy_zablokowany INTO v_is_blocked FROM uzytkownik WHERE id_uzytkownika = p_uid;
    IF v_is_blocked THEN RETURN 'BŁĄD: Konto zablokowane.'; END IF;
    IF p_do <= p_od THEN RETURN 'Błąd: Data wyjazdu musi być późniejsza niż przyjazdu.'; END IF;
    
    SELECT p.cena_doba, p.max_dzieci, h.hotel_id, h.mnoznik_lato, h.mnoznik_zima, h.nazwa
    INTO v_cena, v_max_dzieci, v_hotel_id, v_hotel_lato, v_hotel_zima, v_hotel_nazwa
    FROM pokoje p JOIN hotele h ON p.hotel_id = h.hotel_id WHERE p.id_pokoj = p_pid;
    
    IF v_cena IS NULL THEN RETURN 'Błąd: Brak pokoju.'; END IF;
    IF p_dzieci > v_max_dzieci THEN RETURN 'Błąd: Za dużo dzieci.'; END IF;

    -- 3. DOSTĘPNOŚĆ (z buforem 1 dzień)
    SELECT COUNT(*) INTO v_konflikt FROM rezerwacje 
    WHERE id_pokoj = p_pid AND status NOT LIKE 'anulowana%' 
    AND ((rezerwacja_od < p_do AND rezerwacja_do > p_od) OR (rezerwacja_do + INTERVAL '1 day' >= p_od AND rezerwacja_od < p_do));
    IF v_konflikt > 0 THEN RETURN 'Błąd: Termin zajęty.'; END IF;

    -- 4. YIELD MANAGEMENT (Zajętość Hotelu)
    SELECT COUNT(*) INTO v_total_pokoje FROM pokoje WHERE hotel_id = v_hotel_id;
    SELECT COUNT(DISTINCT r.id_pokoj) INTO v_zajete_pokoje 
    FROM rezerwacje r JOIN pokoje p ON r.id_pokoj = p.id_pokoj
    WHERE p.hotel_id = v_hotel_id AND r.status NOT LIKE 'anulowana%'
    AND (r.rezerwacja_od < p_do AND r.rezerwacja_do > p_od);
    
    IF v_total_pokoje > 0 THEN v_procent_zajetosci := (v_zajete_pokoje::NUMERIC / v_total_pokoje::NUMERIC) * 100;
    ELSE v_procent_zajetosci := 0; END IF;

    SELECT mnoznik, opis INTO v_mnoznik_dyn, v_opis_dyn FROM progi_zajetosci 
    WHERE v_procent_zajetosci BETWEEN procent_od AND procent_do LIMIT 1;

    IF v_mnoznik_dyn IS NOT NULL AND v_mnoznik_dyn != 1.00 THEN
        v_cena := v_cena * v_mnoznik_dyn;
        v_msg_info := v_msg_info || ' (' || v_opis_dyn || ')';
    END IF;

    -- 5. SEZONOWOŚĆ (Indywidualna dla hotelu)
    v_miesiac := EXTRACT(MONTH FROM p_od);
    IF v_miesiac IN (6, 7, 8) THEN 
        IF v_hotel_lato != 1.00 THEN v_cena := v_cena * v_hotel_lato; v_msg_info := v_msg_info || ' (Sezon Lato)'; END IF;
    ELSIF v_miesiac IN (1, 2, 12) THEN 
        IF v_hotel_zima != 1.00 THEN v_cena := v_cena * v_hotel_zima; v_msg_info := v_msg_info || ' (Sezon Zima)'; END IF;
    END IF;

    v_total := (p_do - p_od) * v_cena;

    -- 6. LOJALNOŚĆ
    SELECT COUNT(*) INTO v_historia FROM rezerwacje WHERE id_uzytkownika = p_uid AND status NOT LIKE 'anulowana%';
    IF v_historia >= cfg_prog THEN
        v_rabat := v_total * cfg_rabat_proc;
        v_total := v_total - v_rabat;
        v_msg_info := v_msg_info || ' (Rabat stałego klienta!)';
    END IF;

    -- 7. ZAPIS
    INSERT INTO rezerwacje (id_uzytkownika, id_pokoj, rezerwacja_od, rezerwacja_do, liczba_dzieci, cena_ostateczna)
    VALUES (p_uid, p_pid, p_od, p_do, p_dzieci, v_total) RETURNING id_rezerwacji INTO v_new_id;
    INSERT INTO platnosci (id_rezerwacji, kwota, rabat) VALUES (v_new_id, v_total, v_rabat);

    RETURN 'Sukces! Rez nr ' || v_new_id || '. Kwota: ' || ROUND(v_total, 2) || ' PLN' || v_msg_info;
END;
$$ LANGUAGE plpgsql;

-- FUNKCJA: Anulowanie z Karami (Używa konfiguracji)
CREATE OR REPLACE FUNCTION anuluj_rezerwacje_klienta(p_id_rez INT, p_id_user INT) RETURNS TEXT AS $$
DECLARE
    v_start DATE; v_stat VARCHAR; v_cena NUMERIC; v_dni INT; v_kara NUMERIC;
    cfg_dni INT; cfg_kara_proc NUMERIC;
BEGIN
    SELECT wartosc INTO cfg_dni FROM konfiguracja WHERE klucz='anulowanie_limit_dni';
    SELECT wartosc INTO cfg_kara_proc FROM konfiguracja WHERE klucz='anulowanie_kara_proc';

    SELECT rezerwacja_od, status, cena_ostateczna INTO v_start, v_stat, v_cena
    FROM rezerwacje WHERE id_rezerwacji = p_id_rez AND id_uzytkownika = p_id_user;

    IF v_stat NOT IN ('potwierdzona', 'oczekujaca') THEN RETURN 'Błąd: Nie można anulować.'; END IF;

    v_dni := v_start - CURRENT_DATE;

    IF v_dni >= cfg_dni THEN
        UPDATE rezerwacje SET status = 'anulowana' WHERE id_rezerwacji = p_id_rez;
        UPDATE platnosci SET status = 'zwrocona', kwota = 0 WHERE id_rezerwacji = p_id_rez;
        RETURN 'Sukces! Anulowano bezkosztowo.';
    ELSE
        v_kara := v_cena * cfg_kara_proc;
        UPDATE rezerwacje SET status = 'anulowana_pozno' WHERE id_rezerwacji = p_id_rez;
        UPDATE platnosci SET status = 'kara_umowna', kwota = v_kara WHERE id_rezerwacji = p_id_rez;
        RETURN 'Anulowano późno. Naliczono karę: ' || v_kara || ' PLN.';
    END IF;
END;
$$ LANGUAGE plpgsql;



-- T1: Walidacja Dat
CREATE OR REPLACE FUNCTION waliduj_daty_rezerwacji() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.rezerwacja_do <= NEW.rezerwacja_od THEN RAISE EXCEPTION 'Data wyjazdu musi być po przyjeździe!'; END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trg_walidacja_dat BEFORE INSERT OR UPDATE ON rezerwacje FOR EACH ROW EXECUTE FUNCTION waliduj_daty_rezerwacji();

-- T2: Auto-Płatność
CREATE OR REPLACE FUNCTION auto_status_rezerwacji() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.status = 'oplacona' AND OLD.status != 'oplacona' THEN
        UPDATE rezerwacje SET status = 'oplacona' WHERE id_rezerwacji = NEW.id_rezerwacji;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trg_auto_oplacenie AFTER UPDATE ON platnosci FOR EACH ROW EXECUTE FUNCTION auto_status_rezerwacji();

-- T3: Blokada Usera
CREATE OR REPLACE FUNCTION sprawdz_blokade_klienta() RETURNS TRIGGER AS $$
DECLARE v_zablokowany BOOLEAN;
BEGIN
    SELECT czy_zablokowany INTO v_zablokowany FROM uzytkownik WHERE id_uzytkownika = NEW.id_uzytkownika;
    IF v_zablokowany THEN RAISE EXCEPTION 'BLOKADA: Konto zablokowane.'; END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trg_blokada_bezpieczenstwa BEFORE INSERT ON rezerwacje FOR EACH ROW EXECUTE FUNCTION sprawdz_blokade_klienta();

-- T4: Logi SQL (Audyt)
CREATE OR REPLACE FUNCTION loguj_zmiane_statusu() RETURNS TRIGGER AS $$
BEGIN
    IF OLD.status IS DISTINCT FROM NEW.status THEN
        INSERT INTO logi_systemowe (id_rezerwacji, stary_status, nowy_status, komunikat) 
        VALUES (NEW.id_rezerwacji, OLD.status, NEW.status, 'Zmiana statusu');
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trg_loguj_zmiany AFTER UPDATE ON rezerwacje FOR EACH ROW EXECUTE FUNCTION loguj_zmiane_statusu();

-- T5: Logi NoSQL (JSONB) - WYMAGANIE NA OCENĘ 4.5
CREATE OR REPLACE FUNCTION loguj_zmiane_statusu_json() RETURNS TRIGGER AS $$
DECLARE v_json JSONB;
BEGIN
    IF OLD.status IS DISTINCT FROM NEW.status THEN
        v_json := json_build_object(
            'typ', 'zmiana_statusu', 'id_rez', NEW.id_rezerwacji,
            'szczegoly', json_build_object('stary', OLD.status, 'nowy', NEW.status, 'user', NEW.id_uzytkownika)
        );
        INSERT INTO logi_nosql (dokument_json) VALUES (v_json);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trg_loguj_zmiany_json AFTER UPDATE ON rezerwacje FOR EACH ROW EXECUTE FUNCTION loguj_zmiane_statusu_json();

-- T6: Archiwizacja (Soft Delete)
CREATE OR REPLACE FUNCTION archiwizuj_przed_usunieciem() RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO archiwum_uzytkownikow (id_starego_uzytkownika, email, powod) VALUES (OLD.id_uzytkownika, OLD.email, 'Usunięty');
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trg_archiwizacja_usera BEFORE DELETE ON uzytkownik FOR EACH ROW EXECUTE FUNCTION archiwizuj_przed_usunieciem();


CREATE OR REPLACE VIEW raport_przychodow AS
SELECT h.nazwa AS Hotel, p.typ_pokoju AS Typ, COUNT(r.id_rezerwacji) AS Liczba_Rezerwacji, SUM(r.cena_ostateczna) AS Laczny_Zysk
FROM rezerwacje r JOIN pokoje p ON r.id_pokoj = p.id_pokoj JOIN hotele h ON p.hotel_id = h.hotel_id
WHERE r.status NOT LIKE 'anulowana%'
GROUP BY h.nazwa, p.typ_pokoju ORDER BY Laczny_Zysk DESC;


INSERT INTO hotele (nazwa, miasto, mnoznik_lato, mnoznik_zima) VALUES 
('Grand Hotel', 'Warszawa', 1.00, 1.00),
('Morska Bryza', 'Gdańsk', 1.50, 0.80),
('Góralska Chata', 'Zakopane', 1.10, 1.60);

INSERT INTO pokoje (hotel_id, nr_pokoj, typ_pokoju, cena_doba, pojemnosc, max_dzieci) VALUES 
(1, '101', 'Standard', 200, 2, 0), (1, '201', 'Apartament', 400, 4, 2),
(2, 'G1', 'Widok', 350, 2, 1), (3, 'Z1', 'Drewienko', 300, 2, 0);

INSERT INTO uzytkownik (imie, nazwisko, email, haslo, rola, czy_zablokowany, manager_hotel_id) VALUES 
('Jan', 'Admin', 'admin@hotel.pl', '1234', 'admin', FALSE, NULL),
('Anna', 'VIP', 'anna@vip.pl', '1234', 'klient', FALSE, NULL),
('Piotr', 'Ban', 'ban@test.pl', '1234', 'klient', TRUE, NULL),
('Adam', 'ManagerWaw', 'manager.waw@hotel.pl', '1234', 'manager', FALSE, 1),
('Tomasz', 'Nowy', 'tomek@test.pl', '1234', 'klient', FALSE, NULL);

-- Historia dla VIP
INSERT INTO rezerwacje (id_uzytkownika, id_pokoj, rezerwacja_od, rezerwacja_do, status)
SELECT 2, 1, '2023-01-01', '2023-01-03', 'zrealizowana' FROM generate_series(1, 10);